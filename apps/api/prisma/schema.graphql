# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateColor {
  _count: ColorCountAggregate
  _max: ColorMaxAggregate
  _min: ColorMinAggregate
}

type AggregateCustomer {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
}

type AggregateInventory {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
}

type AggregateLoginHistory {
  _count: LoginHistoryCountAggregate
  _max: LoginHistoryMaxAggregate
  _min: LoginHistoryMinAggregate
}

type AggregateProduct {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
}

type AggregateProductColor {
  _count: ProductColorCountAggregate
  _max: ProductColorMaxAggregate
  _min: ProductColorMinAggregate
}

type AggregateProductSales {
  _avg: ProductSalesAvgAggregate
  _count: ProductSalesCountAggregate
  _max: ProductSalesMaxAggregate
  _min: ProductSalesMinAggregate
  _sum: ProductSalesSumAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type Color {
  ProductColor(cursor: ProductColorWhereUniqueInput, distinct: [ProductColorScalarFieldEnum!], orderBy: [ProductColorOrderByWithRelationInput!], skip: Int, take: Int, where: ProductColorWhereInput): [ProductColor!]!
  _count: ColorCount
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
}

type ColorCount {
  ProductColor(where: ProductColorWhereInput): Int!
}

type ColorCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  name: Int!
}

input ColorCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input ColorCreateInput {
  ProductColor: ProductColorCreateNestedManyWithoutColorInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
}

input ColorCreateManyInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
}

input ColorCreateNestedOneWithoutProductColorInput {
  connect: ColorWhereUniqueInput
  connectOrCreate: ColorCreateOrConnectWithoutProductColorInput
  create: ColorCreateWithoutProductColorInput
}

input ColorCreateOrConnectWithoutProductColorInput {
  create: ColorCreateWithoutProductColorInput!
  where: ColorWhereUniqueInput!
}

input ColorCreateWithoutProductColorInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String!
}

type ColorGroupBy {
  _count: ColorCountAggregate
  _max: ColorMaxAggregate
  _min: ColorMinAggregate
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
}

type ColorMaxAggregate {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
}

input ColorMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

type ColorMinAggregate {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
}

input ColorMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input ColorOrderByWithAggregationInput {
  _count: ColorCountOrderByAggregateInput
  _max: ColorMaxOrderByAggregateInput
  _min: ColorMinOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input ColorOrderByWithRelationInput {
  ProductColor: ProductColorOrderByRelationAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  name: SortOrder
}

input ColorRelationFilter {
  is: ColorWhereInput
  isNot: ColorWhereInput
}

enum ColorScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  name
}

input ColorScalarWhereWithAggregatesInput {
  AND: [ColorScalarWhereWithAggregatesInput!]
  NOT: [ColorScalarWhereWithAggregatesInput!]
  OR: [ColorScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
}

input ColorUpdateInput {
  ProductColor: ProductColorUpdateManyWithoutColorNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
}

input ColorUpdateManyMutationInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
}

input ColorUpdateOneRequiredWithoutProductColorNestedInput {
  connect: ColorWhereUniqueInput
  connectOrCreate: ColorCreateOrConnectWithoutProductColorInput
  create: ColorCreateWithoutProductColorInput
  update: ColorUpdateToOneWithWhereWithoutProductColorInput
  upsert: ColorUpsertWithoutProductColorInput
}

input ColorUpdateToOneWithWhereWithoutProductColorInput {
  data: ColorUpdateWithoutProductColorInput!
  where: ColorWhereInput
}

input ColorUpdateWithoutProductColorInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  name: String
}

input ColorUpsertWithoutProductColorInput {
  create: ColorCreateWithoutProductColorInput!
  update: ColorUpdateWithoutProductColorInput!
  where: ColorWhereInput
}

input ColorWhereInput {
  AND: [ColorWhereInput!]
  NOT: [ColorWhereInput!]
  OR: [ColorWhereInput!]
  ProductColor: ProductColorListRelationFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  name: StringFilter
}

input ColorWhereUniqueInput {
  AND: [ColorWhereInput!]
  NOT: [ColorWhereInput!]
  OR: [ColorWhereInput!]
  ProductColor: ProductColorListRelationFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: String
  name: StringFilter
}

type CreateManyAndReturnColor {
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  name: String!
}

type CreateManyAndReturnCustomer {
  address: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
}

type CreateManyAndReturnInventory {
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  product: Product!
  productId: String!
  quantity: Int!
  size: String!
}

type CreateManyAndReturnLoginHistory {
  id: String!
  loginTime: DateTimeISO!
  user: User!
  userId: String!
}

type CreateManyAndReturnProduct {
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  description: String!
  id: String!
  name: String!
  price: Float!
  type: String!
}

type CreateManyAndReturnProductColor {
  color: Color!
  colorId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  product: Product!
  productId: String!
}

type CreateManyAndReturnProductSales {
  Customer: Customer!
  User: User!
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  price: Float!
  product: Product!
  productId: String!
  quantity: Int!
  userId: String!
}

type CreateManyAndReturnUser {
  address: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

type Customer {
  _count: CustomerCount
  address: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
  productSales(cursor: ProductSalesWhereUniqueInput, distinct: [ProductSalesScalarFieldEnum!], orderBy: [ProductSalesOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): [ProductSales!]!
}

type CustomerCount {
  productSales(where: ProductSalesWhereInput): Int!
}

type CustomerCountAggregate {
  _all: Int!
  address: Int!
  dateCreated: Int!
  dateUpdated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  phone: Int!
}

input CustomerCountOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

input CustomerCreateInput {
  address: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
  productSales: ProductSalesCreateNestedManyWithoutCustomerInput
}

input CustomerCreateManyInput {
  address: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
}

input CustomerCreateNestedOneWithoutProductSalesInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutProductSalesInput
  create: CustomerCreateWithoutProductSalesInput
}

input CustomerCreateOrConnectWithoutProductSalesInput {
  create: CustomerCreateWithoutProductSalesInput!
  where: CustomerWhereUniqueInput!
}

input CustomerCreateWithoutProductSalesInput {
  address: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  phone: String!
}

type CustomerGroupBy {
  _count: CustomerCountAggregate
  _max: CustomerMaxAggregate
  _min: CustomerMinAggregate
  address: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  phone: String!
}

type CustomerMaxAggregate {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerMaxOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

type CustomerMinAggregate {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerMinOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

input CustomerOrderByWithAggregationInput {
  _count: CustomerCountOrderByAggregateInput
  _max: CustomerMaxOrderByAggregateInput
  _min: CustomerMinOrderByAggregateInput
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
}

input CustomerOrderByWithRelationInput {
  address: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  phone: SortOrder
  productSales: ProductSalesOrderByRelationAggregateInput
}

input CustomerRelationFilter {
  is: CustomerWhereInput
  isNot: CustomerWhereInput
}

enum CustomerScalarFieldEnum {
  address
  dateCreated
  dateUpdated
  email
  firstName
  id
  lastName
  phone
}

input CustomerScalarWhereWithAggregatesInput {
  AND: [CustomerScalarWhereWithAggregatesInput!]
  NOT: [CustomerScalarWhereWithAggregatesInput!]
  OR: [CustomerScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
}

input CustomerUpdateInput {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
  productSales: ProductSalesUpdateManyWithoutCustomerNestedInput
}

input CustomerUpdateManyMutationInput {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerUpdateOneRequiredWithoutProductSalesNestedInput {
  connect: CustomerWhereUniqueInput
  connectOrCreate: CustomerCreateOrConnectWithoutProductSalesInput
  create: CustomerCreateWithoutProductSalesInput
  update: CustomerUpdateToOneWithWhereWithoutProductSalesInput
  upsert: CustomerUpsertWithoutProductSalesInput
}

input CustomerUpdateToOneWithWhereWithoutProductSalesInput {
  data: CustomerUpdateWithoutProductSalesInput!
  where: CustomerWhereInput
}

input CustomerUpdateWithoutProductSalesInput {
  address: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  phone: String
}

input CustomerUpsertWithoutProductSalesInput {
  create: CustomerCreateWithoutProductSalesInput!
  update: CustomerUpdateWithoutProductSalesInput!
  where: CustomerWhereInput
}

input CustomerWhereInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  phone: StringFilter
  productSales: ProductSalesListRelationFilter
}

input CustomerWhereUniqueInput {
  AND: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  email: String
  firstName: StringFilter
  id: String
  lastName: StringFilter
  phone: StringFilter
  productSales: ProductSalesListRelationFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Inventory {
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  product: Product!
  productId: String!
  quantity: Int!
  size: String!
}

type InventoryAvgAggregate {
  quantity: Float
}

input InventoryAvgOrderByAggregateInput {
  quantity: SortOrder
}

type InventoryCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  productId: Int!
  quantity: Int!
  size: Int!
}

input InventoryCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  size: SortOrder
}

input InventoryCreateInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  product: ProductCreateNestedOneWithoutInventoryInput!
  quantity: Int!
  size: String!
}

input InventoryCreateManyInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  productId: String!
  quantity: Int!
  size: String!
}

input InventoryCreateManyProductInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  quantity: Int!
  size: String!
}

input InventoryCreateManyProductInputEnvelope {
  data: [InventoryCreateManyProductInput!]!
}

input InventoryCreateNestedManyWithoutProductInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutProductInput!]
  create: [InventoryCreateWithoutProductInput!]
  createMany: InventoryCreateManyProductInputEnvelope
}

input InventoryCreateOrConnectWithoutProductInput {
  create: InventoryCreateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryCreateWithoutProductInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  quantity: Int!
  size: String!
}

type InventoryGroupBy {
  _avg: InventoryAvgAggregate
  _count: InventoryCountAggregate
  _max: InventoryMaxAggregate
  _min: InventoryMinAggregate
  _sum: InventorySumAggregate
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  productId: String!
  quantity: Int!
  size: String!
}

input InventoryListRelationFilter {
  every: InventoryWhereInput
  none: InventoryWhereInput
  some: InventoryWhereInput
}

type InventoryMaxAggregate {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  productId: String
  quantity: Int
  size: String
}

input InventoryMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  size: SortOrder
}

type InventoryMinAggregate {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  productId: String
  quantity: Int
  size: String
}

input InventoryMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  size: SortOrder
}

input InventoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input InventoryOrderByWithAggregationInput {
  _avg: InventoryAvgOrderByAggregateInput
  _count: InventoryCountOrderByAggregateInput
  _max: InventoryMaxOrderByAggregateInput
  _min: InventoryMinOrderByAggregateInput
  _sum: InventorySumOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
  quantity: SortOrder
  size: SortOrder
}

input InventoryOrderByWithRelationInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  size: SortOrder
}

enum InventoryScalarFieldEnum {
  dateCreated
  dateUpdated
  id
  productId
  quantity
  size
}

input InventoryScalarWhereInput {
  AND: [InventoryScalarWhereInput!]
  NOT: [InventoryScalarWhereInput!]
  OR: [InventoryScalarWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  productId: StringFilter
  quantity: IntFilter
  size: StringFilter
}

input InventoryScalarWhereWithAggregatesInput {
  AND: [InventoryScalarWhereWithAggregatesInput!]
  NOT: [InventoryScalarWhereWithAggregatesInput!]
  OR: [InventoryScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  size: StringWithAggregatesFilter
}

type InventorySumAggregate {
  quantity: Int
}

input InventorySumOrderByAggregateInput {
  quantity: SortOrder
}

input InventoryUpdateInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  product: ProductUpdateOneRequiredWithoutInventoryNestedInput
  quantity: Int
  size: String
}

input InventoryUpdateManyMutationInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  quantity: Int
  size: String
}

input InventoryUpdateManyWithWhereWithoutProductInput {
  data: InventoryUpdateManyMutationInput!
  where: InventoryScalarWhereInput!
}

input InventoryUpdateManyWithoutProductNestedInput {
  connect: [InventoryWhereUniqueInput!]
  connectOrCreate: [InventoryCreateOrConnectWithoutProductInput!]
  create: [InventoryCreateWithoutProductInput!]
  createMany: InventoryCreateManyProductInputEnvelope
  delete: [InventoryWhereUniqueInput!]
  deleteMany: [InventoryScalarWhereInput!]
  disconnect: [InventoryWhereUniqueInput!]
  set: [InventoryWhereUniqueInput!]
  update: [InventoryUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [InventoryUpdateManyWithWhereWithoutProductInput!]
  upsert: [InventoryUpsertWithWhereUniqueWithoutProductInput!]
}

input InventoryUpdateWithWhereUniqueWithoutProductInput {
  data: InventoryUpdateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryUpdateWithoutProductInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  quantity: Int
  size: String
}

input InventoryUpsertWithWhereUniqueWithoutProductInput {
  create: InventoryCreateWithoutProductInput!
  update: InventoryUpdateWithoutProductInput!
  where: InventoryWhereUniqueInput!
}

input InventoryWhereInput {
  AND: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  size: StringFilter
}

input InventoryWhereUniqueInput {
  AND: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: String
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  size: StringFilter
}

type LoginHistory {
  id: String!
  loginTime: DateTimeISO!
  user: User!
  userId: String!
}

type LoginHistoryCountAggregate {
  _all: Int!
  id: Int!
  loginTime: Int!
  userId: Int!
}

input LoginHistoryCountOrderByAggregateInput {
  id: SortOrder
  loginTime: SortOrder
  userId: SortOrder
}

input LoginHistoryCreateInput {
  id: String
  loginTime: DateTimeISO
  user: UserCreateNestedOneWithoutLoginHistoryInput!
}

input LoginHistoryCreateManyInput {
  id: String
  loginTime: DateTimeISO
  userId: String!
}

input LoginHistoryCreateManyUserInput {
  id: String
  loginTime: DateTimeISO
}

input LoginHistoryCreateManyUserInputEnvelope {
  data: [LoginHistoryCreateManyUserInput!]!
}

input LoginHistoryCreateNestedManyWithoutUserInput {
  connect: [LoginHistoryWhereUniqueInput!]
  connectOrCreate: [LoginHistoryCreateOrConnectWithoutUserInput!]
  create: [LoginHistoryCreateWithoutUserInput!]
  createMany: LoginHistoryCreateManyUserInputEnvelope
}

input LoginHistoryCreateOrConnectWithoutUserInput {
  create: LoginHistoryCreateWithoutUserInput!
  where: LoginHistoryWhereUniqueInput!
}

input LoginHistoryCreateWithoutUserInput {
  id: String
  loginTime: DateTimeISO
}

type LoginHistoryGroupBy {
  _count: LoginHistoryCountAggregate
  _max: LoginHistoryMaxAggregate
  _min: LoginHistoryMinAggregate
  id: String!
  loginTime: DateTimeISO!
  userId: String!
}

input LoginHistoryListRelationFilter {
  every: LoginHistoryWhereInput
  none: LoginHistoryWhereInput
  some: LoginHistoryWhereInput
}

type LoginHistoryMaxAggregate {
  id: String
  loginTime: DateTimeISO
  userId: String
}

input LoginHistoryMaxOrderByAggregateInput {
  id: SortOrder
  loginTime: SortOrder
  userId: SortOrder
}

type LoginHistoryMinAggregate {
  id: String
  loginTime: DateTimeISO
  userId: String
}

input LoginHistoryMinOrderByAggregateInput {
  id: SortOrder
  loginTime: SortOrder
  userId: SortOrder
}

input LoginHistoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input LoginHistoryOrderByWithAggregationInput {
  _count: LoginHistoryCountOrderByAggregateInput
  _max: LoginHistoryMaxOrderByAggregateInput
  _min: LoginHistoryMinOrderByAggregateInput
  id: SortOrder
  loginTime: SortOrder
  userId: SortOrder
}

input LoginHistoryOrderByWithRelationInput {
  id: SortOrder
  loginTime: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum LoginHistoryScalarFieldEnum {
  id
  loginTime
  userId
}

input LoginHistoryScalarWhereInput {
  AND: [LoginHistoryScalarWhereInput!]
  NOT: [LoginHistoryScalarWhereInput!]
  OR: [LoginHistoryScalarWhereInput!]
  id: StringFilter
  loginTime: DateTimeFilter
  userId: StringFilter
}

input LoginHistoryScalarWhereWithAggregatesInput {
  AND: [LoginHistoryScalarWhereWithAggregatesInput!]
  NOT: [LoginHistoryScalarWhereWithAggregatesInput!]
  OR: [LoginHistoryScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  loginTime: DateTimeWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input LoginHistoryUpdateInput {
  id: String
  loginTime: DateTimeISO
  user: UserUpdateOneRequiredWithoutLoginHistoryNestedInput
}

input LoginHistoryUpdateManyMutationInput {
  id: String
  loginTime: DateTimeISO
}

input LoginHistoryUpdateManyWithWhereWithoutUserInput {
  data: LoginHistoryUpdateManyMutationInput!
  where: LoginHistoryScalarWhereInput!
}

input LoginHistoryUpdateManyWithoutUserNestedInput {
  connect: [LoginHistoryWhereUniqueInput!]
  connectOrCreate: [LoginHistoryCreateOrConnectWithoutUserInput!]
  create: [LoginHistoryCreateWithoutUserInput!]
  createMany: LoginHistoryCreateManyUserInputEnvelope
  delete: [LoginHistoryWhereUniqueInput!]
  deleteMany: [LoginHistoryScalarWhereInput!]
  disconnect: [LoginHistoryWhereUniqueInput!]
  set: [LoginHistoryWhereUniqueInput!]
  update: [LoginHistoryUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [LoginHistoryUpdateManyWithWhereWithoutUserInput!]
  upsert: [LoginHistoryUpsertWithWhereUniqueWithoutUserInput!]
}

input LoginHistoryUpdateWithWhereUniqueWithoutUserInput {
  data: LoginHistoryUpdateWithoutUserInput!
  where: LoginHistoryWhereUniqueInput!
}

input LoginHistoryUpdateWithoutUserInput {
  id: String
  loginTime: DateTimeISO
}

input LoginHistoryUpsertWithWhereUniqueWithoutUserInput {
  create: LoginHistoryCreateWithoutUserInput!
  update: LoginHistoryUpdateWithoutUserInput!
  where: LoginHistoryWhereUniqueInput!
}

input LoginHistoryWhereInput {
  AND: [LoginHistoryWhereInput!]
  NOT: [LoginHistoryWhereInput!]
  OR: [LoginHistoryWhereInput!]
  id: StringFilter
  loginTime: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

input LoginHistoryWhereUniqueInput {
  AND: [LoginHistoryWhereInput!]
  NOT: [LoginHistoryWhereInput!]
  OR: [LoginHistoryWhereInput!]
  id: String
  loginTime: DateTimeFilter
  user: UserRelationFilter
  userId: StringFilter
}

type Mutation {
  createManyAndReturnColor(data: [ColorCreateManyInput!]!): [CreateManyAndReturnColor!]!
  createManyAndReturnCustomer(data: [CustomerCreateManyInput!]!): [CreateManyAndReturnCustomer!]!
  createManyAndReturnInventory(data: [InventoryCreateManyInput!]!): [CreateManyAndReturnInventory!]!
  createManyAndReturnLoginHistory(data: [LoginHistoryCreateManyInput!]!): [CreateManyAndReturnLoginHistory!]!
  createManyAndReturnProduct(data: [ProductCreateManyInput!]!): [CreateManyAndReturnProduct!]!
  createManyAndReturnProductColor(data: [ProductColorCreateManyInput!]!): [CreateManyAndReturnProductColor!]!
  createManyAndReturnProductSales(data: [ProductSalesCreateManyInput!]!): [CreateManyAndReturnProductSales!]!
  createManyAndReturnUser(data: [UserCreateManyInput!]!): [CreateManyAndReturnUser!]!
  createManyColor(data: [ColorCreateManyInput!]!): AffectedRowsOutput!
  createManyCustomer(data: [CustomerCreateManyInput!]!): AffectedRowsOutput!
  createManyInventory(data: [InventoryCreateManyInput!]!): AffectedRowsOutput!
  createManyLoginHistory(data: [LoginHistoryCreateManyInput!]!): AffectedRowsOutput!
  createManyProduct(data: [ProductCreateManyInput!]!): AffectedRowsOutput!
  createManyProductColor(data: [ProductColorCreateManyInput!]!): AffectedRowsOutput!
  createManyProductSales(data: [ProductSalesCreateManyInput!]!): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!): AffectedRowsOutput!
  createOneColor(data: ColorCreateInput!): Color!
  createOneCustomer(data: CustomerCreateInput!): Customer!
  createOneInventory(data: InventoryCreateInput!): Inventory!
  createOneLoginHistory(data: LoginHistoryCreateInput!): LoginHistory!
  createOneProduct(data: ProductCreateInput!): Product!
  createOneProductColor(data: ProductColorCreateInput!): ProductColor!
  createOneProductSales(data: ProductSalesCreateInput!): ProductSales!
  createOneUser(data: UserCreateInput!): User!
  deleteManyColor(where: ColorWhereInput): AffectedRowsOutput!
  deleteManyCustomer(where: CustomerWhereInput): AffectedRowsOutput!
  deleteManyInventory(where: InventoryWhereInput): AffectedRowsOutput!
  deleteManyLoginHistory(where: LoginHistoryWhereInput): AffectedRowsOutput!
  deleteManyProduct(where: ProductWhereInput): AffectedRowsOutput!
  deleteManyProductColor(where: ProductColorWhereInput): AffectedRowsOutput!
  deleteManyProductSales(where: ProductSalesWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneColor(where: ColorWhereUniqueInput!): Color
  deleteOneCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteOneInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteOneLoginHistory(where: LoginHistoryWhereUniqueInput!): LoginHistory
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  deleteOneProductColor(where: ProductColorWhereUniqueInput!): ProductColor
  deleteOneProductSales(where: ProductSalesWhereUniqueInput!): ProductSales
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyColor(data: ColorUpdateManyMutationInput!, where: ColorWhereInput): AffectedRowsOutput!
  updateManyCustomer(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): AffectedRowsOutput!
  updateManyInventory(data: InventoryUpdateManyMutationInput!, where: InventoryWhereInput): AffectedRowsOutput!
  updateManyLoginHistory(data: LoginHistoryUpdateManyMutationInput!, where: LoginHistoryWhereInput): AffectedRowsOutput!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): AffectedRowsOutput!
  updateManyProductColor(data: ProductColorUpdateManyMutationInput!, where: ProductColorWhereInput): AffectedRowsOutput!
  updateManyProductSales(data: ProductSalesUpdateManyMutationInput!, where: ProductSalesWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneColor(data: ColorUpdateInput!, where: ColorWhereUniqueInput!): Color
  updateOneCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateOneInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  updateOneLoginHistory(data: LoginHistoryUpdateInput!, where: LoginHistoryWhereUniqueInput!): LoginHistory
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateOneProductColor(data: ProductColorUpdateInput!, where: ProductColorWhereUniqueInput!): ProductColor
  updateOneProductSales(data: ProductSalesUpdateInput!, where: ProductSalesWhereUniqueInput!): ProductSales
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneColor(create: ColorCreateInput!, update: ColorUpdateInput!, where: ColorWhereUniqueInput!): Color!
  upsertOneCustomer(create: CustomerCreateInput!, update: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer!
  upsertOneInventory(create: InventoryCreateInput!, update: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory!
  upsertOneLoginHistory(create: LoginHistoryCreateInput!, update: LoginHistoryUpdateInput!, where: LoginHistoryWhereUniqueInput!): LoginHistory!
  upsertOneProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertOneProductColor(create: ProductColorCreateInput!, update: ProductColorUpdateInput!, where: ProductColorWhereUniqueInput!): ProductColor!
  upsertOneProductSales(create: ProductSalesCreateInput!, update: ProductSalesUpdateInput!, where: ProductSalesWhereUniqueInput!): ProductSales!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Product {
  Inventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  ProductColor(cursor: ProductColorWhereUniqueInput, distinct: [ProductColorScalarFieldEnum!], orderBy: [ProductColorOrderByWithRelationInput!], skip: Int, take: Int, where: ProductColorWhereInput): [ProductColor!]!
  ProductSales(cursor: ProductSalesWhereUniqueInput, distinct: [ProductSalesScalarFieldEnum!], orderBy: [ProductSalesOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): [ProductSales!]!
  _count: ProductCount
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  description: String!
  id: String!
  name: String!
  price: Float!
  type: String!
}

type ProductAvgAggregate {
  price: Float
}

input ProductAvgOrderByAggregateInput {
  price: SortOrder
}

type ProductColor {
  color: Color!
  colorId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  product: Product!
  productId: String!
}

type ProductColorCountAggregate {
  _all: Int!
  colorId: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  productId: Int!
}

input ProductColorCountOrderByAggregateInput {
  colorId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
}

input ProductColorCreateInput {
  color: ColorCreateNestedOneWithoutProductColorInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  product: ProductCreateNestedOneWithoutProductColorInput!
}

input ProductColorCreateManyColorInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  productId: String!
}

input ProductColorCreateManyColorInputEnvelope {
  data: [ProductColorCreateManyColorInput!]!
}

input ProductColorCreateManyInput {
  colorId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  productId: String!
}

input ProductColorCreateManyProductInput {
  colorId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
}

input ProductColorCreateManyProductInputEnvelope {
  data: [ProductColorCreateManyProductInput!]!
}

input ProductColorCreateNestedManyWithoutColorInput {
  connect: [ProductColorWhereUniqueInput!]
  connectOrCreate: [ProductColorCreateOrConnectWithoutColorInput!]
  create: [ProductColorCreateWithoutColorInput!]
  createMany: ProductColorCreateManyColorInputEnvelope
}

input ProductColorCreateNestedManyWithoutProductInput {
  connect: [ProductColorWhereUniqueInput!]
  connectOrCreate: [ProductColorCreateOrConnectWithoutProductInput!]
  create: [ProductColorCreateWithoutProductInput!]
  createMany: ProductColorCreateManyProductInputEnvelope
}

input ProductColorCreateOrConnectWithoutColorInput {
  create: ProductColorCreateWithoutColorInput!
  where: ProductColorWhereUniqueInput!
}

input ProductColorCreateOrConnectWithoutProductInput {
  create: ProductColorCreateWithoutProductInput!
  where: ProductColorWhereUniqueInput!
}

input ProductColorCreateWithoutColorInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  product: ProductCreateNestedOneWithoutProductColorInput!
}

input ProductColorCreateWithoutProductInput {
  color: ColorCreateNestedOneWithoutProductColorInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
}

type ProductColorGroupBy {
  _count: ProductColorCountAggregate
  _max: ProductColorMaxAggregate
  _min: ProductColorMinAggregate
  colorId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  productId: String!
}

input ProductColorListRelationFilter {
  every: ProductColorWhereInput
  none: ProductColorWhereInput
  some: ProductColorWhereInput
}

type ProductColorMaxAggregate {
  colorId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  productId: String
}

input ProductColorMaxOrderByAggregateInput {
  colorId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
}

type ProductColorMinAggregate {
  colorId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  productId: String
}

input ProductColorMinOrderByAggregateInput {
  colorId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
}

input ProductColorOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductColorOrderByWithAggregationInput {
  _count: ProductColorCountOrderByAggregateInput
  _max: ProductColorMaxOrderByAggregateInput
  _min: ProductColorMinOrderByAggregateInput
  colorId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  productId: SortOrder
}

input ProductColorOrderByWithRelationInput {
  color: ColorOrderByWithRelationInput
  colorId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
}

enum ProductColorScalarFieldEnum {
  colorId
  dateCreated
  dateUpdated
  id
  productId
}

input ProductColorScalarWhereInput {
  AND: [ProductColorScalarWhereInput!]
  NOT: [ProductColorScalarWhereInput!]
  OR: [ProductColorScalarWhereInput!]
  colorId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  productId: StringFilter
}

input ProductColorScalarWhereWithAggregatesInput {
  AND: [ProductColorScalarWhereWithAggregatesInput!]
  NOT: [ProductColorScalarWhereWithAggregatesInput!]
  OR: [ProductColorScalarWhereWithAggregatesInput!]
  colorId: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  productId: StringWithAggregatesFilter
}

input ProductColorUpdateInput {
  color: ColorUpdateOneRequiredWithoutProductColorNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  product: ProductUpdateOneRequiredWithoutProductColorNestedInput
}

input ProductColorUpdateManyMutationInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
}

input ProductColorUpdateManyWithWhereWithoutColorInput {
  data: ProductColorUpdateManyMutationInput!
  where: ProductColorScalarWhereInput!
}

input ProductColorUpdateManyWithWhereWithoutProductInput {
  data: ProductColorUpdateManyMutationInput!
  where: ProductColorScalarWhereInput!
}

input ProductColorUpdateManyWithoutColorNestedInput {
  connect: [ProductColorWhereUniqueInput!]
  connectOrCreate: [ProductColorCreateOrConnectWithoutColorInput!]
  create: [ProductColorCreateWithoutColorInput!]
  createMany: ProductColorCreateManyColorInputEnvelope
  delete: [ProductColorWhereUniqueInput!]
  deleteMany: [ProductColorScalarWhereInput!]
  disconnect: [ProductColorWhereUniqueInput!]
  set: [ProductColorWhereUniqueInput!]
  update: [ProductColorUpdateWithWhereUniqueWithoutColorInput!]
  updateMany: [ProductColorUpdateManyWithWhereWithoutColorInput!]
  upsert: [ProductColorUpsertWithWhereUniqueWithoutColorInput!]
}

input ProductColorUpdateManyWithoutProductNestedInput {
  connect: [ProductColorWhereUniqueInput!]
  connectOrCreate: [ProductColorCreateOrConnectWithoutProductInput!]
  create: [ProductColorCreateWithoutProductInput!]
  createMany: ProductColorCreateManyProductInputEnvelope
  delete: [ProductColorWhereUniqueInput!]
  deleteMany: [ProductColorScalarWhereInput!]
  disconnect: [ProductColorWhereUniqueInput!]
  set: [ProductColorWhereUniqueInput!]
  update: [ProductColorUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ProductColorUpdateManyWithWhereWithoutProductInput!]
  upsert: [ProductColorUpsertWithWhereUniqueWithoutProductInput!]
}

input ProductColorUpdateWithWhereUniqueWithoutColorInput {
  data: ProductColorUpdateWithoutColorInput!
  where: ProductColorWhereUniqueInput!
}

input ProductColorUpdateWithWhereUniqueWithoutProductInput {
  data: ProductColorUpdateWithoutProductInput!
  where: ProductColorWhereUniqueInput!
}

input ProductColorUpdateWithoutColorInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  product: ProductUpdateOneRequiredWithoutProductColorNestedInput
}

input ProductColorUpdateWithoutProductInput {
  color: ColorUpdateOneRequiredWithoutProductColorNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
}

input ProductColorUpsertWithWhereUniqueWithoutColorInput {
  create: ProductColorCreateWithoutColorInput!
  update: ProductColorUpdateWithoutColorInput!
  where: ProductColorWhereUniqueInput!
}

input ProductColorUpsertWithWhereUniqueWithoutProductInput {
  create: ProductColorCreateWithoutProductInput!
  update: ProductColorUpdateWithoutProductInput!
  where: ProductColorWhereUniqueInput!
}

input ProductColorWhereInput {
  AND: [ProductColorWhereInput!]
  NOT: [ProductColorWhereInput!]
  OR: [ProductColorWhereInput!]
  color: ColorRelationFilter
  colorId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  product: ProductRelationFilter
  productId: StringFilter
}

input ProductColorWhereUniqueInput {
  AND: [ProductColorWhereInput!]
  NOT: [ProductColorWhereInput!]
  OR: [ProductColorWhereInput!]
  color: ColorRelationFilter
  colorId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: String
  product: ProductRelationFilter
  productId: StringFilter
}

type ProductCount {
  Inventory(where: InventoryWhereInput): Int!
  ProductColor(where: ProductColorWhereInput): Int!
  ProductSales(where: ProductSalesWhereInput): Int!
}

type ProductCountAggregate {
  _all: Int!
  dateCreated: Int!
  dateUpdated: Int!
  description: Int!
  id: Int!
  name: Int!
  price: Int!
  type: Int!
}

input ProductCountOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  type: SortOrder
}

input ProductCreateInput {
  Inventory: InventoryCreateNestedManyWithoutProductInput
  ProductColor: ProductColorCreateNestedManyWithoutProductInput
  ProductSales: ProductSalesCreateNestedManyWithoutProductInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String!
  id: String
  name: String!
  price: Float!
  type: String!
}

input ProductCreateManyInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String!
  id: String
  name: String!
  price: Float!
  type: String!
}

input ProductCreateNestedOneWithoutInventoryInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInventoryInput
  create: ProductCreateWithoutInventoryInput
}

input ProductCreateNestedOneWithoutProductColorInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductColorInput
  create: ProductCreateWithoutProductColorInput
}

input ProductCreateNestedOneWithoutProductSalesInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductSalesInput
  create: ProductCreateWithoutProductSalesInput
}

input ProductCreateOrConnectWithoutInventoryInput {
  create: ProductCreateWithoutInventoryInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutProductColorInput {
  create: ProductCreateWithoutProductColorInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutProductSalesInput {
  create: ProductCreateWithoutProductSalesInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutInventoryInput {
  ProductColor: ProductColorCreateNestedManyWithoutProductInput
  ProductSales: ProductSalesCreateNestedManyWithoutProductInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String!
  id: String
  name: String!
  price: Float!
  type: String!
}

input ProductCreateWithoutProductColorInput {
  Inventory: InventoryCreateNestedManyWithoutProductInput
  ProductSales: ProductSalesCreateNestedManyWithoutProductInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String!
  id: String
  name: String!
  price: Float!
  type: String!
}

input ProductCreateWithoutProductSalesInput {
  Inventory: InventoryCreateNestedManyWithoutProductInput
  ProductColor: ProductColorCreateNestedManyWithoutProductInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String!
  id: String
  name: String!
  price: Float!
  type: String!
}

type ProductGroupBy {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  description: String!
  id: String!
  name: String!
  price: Float!
  type: String!
}

type ProductMaxAggregate {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String
  id: String
  name: String
  price: Float
  type: String
}

input ProductMaxOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  type: SortOrder
}

type ProductMinAggregate {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String
  id: String
  name: String
  price: Float
  type: String
}

input ProductMinOrderByAggregateInput {
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  type: SortOrder
}

input ProductOrderByWithAggregationInput {
  _avg: ProductAvgOrderByAggregateInput
  _count: ProductCountOrderByAggregateInput
  _max: ProductMaxOrderByAggregateInput
  _min: ProductMinOrderByAggregateInput
  _sum: ProductSumOrderByAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  type: SortOrder
}

input ProductOrderByWithRelationInput {
  Inventory: InventoryOrderByRelationAggregateInput
  ProductColor: ProductColorOrderByRelationAggregateInput
  ProductSales: ProductSalesOrderByRelationAggregateInput
  dateCreated: SortOrder
  dateUpdated: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
  price: SortOrder
  type: SortOrder
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

type ProductSales {
  Customer: Customer!
  User: User!
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  price: Float!
  product: Product!
  productId: String!
  quantity: Int!
  userId: String!
}

type ProductSalesAvgAggregate {
  price: Float
  quantity: Float
}

input ProductSalesAvgOrderByAggregateInput {
  price: SortOrder
  quantity: SortOrder
}

type ProductSalesCountAggregate {
  _all: Int!
  customerId: Int!
  dateCreated: Int!
  dateUpdated: Int!
  id: Int!
  price: Int!
  productId: Int!
  quantity: Int!
  userId: Int!
}

input ProductSalesCountOrderByAggregateInput {
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  userId: SortOrder
}

input ProductSalesCreateInput {
  Customer: CustomerCreateNestedOneWithoutProductSalesInput!
  User: UserCreateNestedOneWithoutProductSalesInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  product: ProductCreateNestedOneWithoutProductSalesInput!
  quantity: Int!
}

input ProductSalesCreateManyCustomerInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  productId: String!
  quantity: Int!
  userId: String!
}

input ProductSalesCreateManyCustomerInputEnvelope {
  data: [ProductSalesCreateManyCustomerInput!]!
}

input ProductSalesCreateManyInput {
  customerId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  productId: String!
  quantity: Int!
  userId: String!
}

input ProductSalesCreateManyProductInput {
  customerId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  quantity: Int!
  userId: String!
}

input ProductSalesCreateManyProductInputEnvelope {
  data: [ProductSalesCreateManyProductInput!]!
}

input ProductSalesCreateManyUserInput {
  customerId: String!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  productId: String!
  quantity: Int!
}

input ProductSalesCreateManyUserInputEnvelope {
  data: [ProductSalesCreateManyUserInput!]!
}

input ProductSalesCreateNestedManyWithoutCustomerInput {
  connect: [ProductSalesWhereUniqueInput!]
  connectOrCreate: [ProductSalesCreateOrConnectWithoutCustomerInput!]
  create: [ProductSalesCreateWithoutCustomerInput!]
  createMany: ProductSalesCreateManyCustomerInputEnvelope
}

input ProductSalesCreateNestedManyWithoutProductInput {
  connect: [ProductSalesWhereUniqueInput!]
  connectOrCreate: [ProductSalesCreateOrConnectWithoutProductInput!]
  create: [ProductSalesCreateWithoutProductInput!]
  createMany: ProductSalesCreateManyProductInputEnvelope
}

input ProductSalesCreateNestedManyWithoutUserInput {
  connect: [ProductSalesWhereUniqueInput!]
  connectOrCreate: [ProductSalesCreateOrConnectWithoutUserInput!]
  create: [ProductSalesCreateWithoutUserInput!]
  createMany: ProductSalesCreateManyUserInputEnvelope
}

input ProductSalesCreateOrConnectWithoutCustomerInput {
  create: ProductSalesCreateWithoutCustomerInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesCreateOrConnectWithoutProductInput {
  create: ProductSalesCreateWithoutProductInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesCreateOrConnectWithoutUserInput {
  create: ProductSalesCreateWithoutUserInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesCreateWithoutCustomerInput {
  User: UserCreateNestedOneWithoutProductSalesInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  product: ProductCreateNestedOneWithoutProductSalesInput!
  quantity: Int!
}

input ProductSalesCreateWithoutProductInput {
  Customer: CustomerCreateNestedOneWithoutProductSalesInput!
  User: UserCreateNestedOneWithoutProductSalesInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  quantity: Int!
}

input ProductSalesCreateWithoutUserInput {
  Customer: CustomerCreateNestedOneWithoutProductSalesInput!
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float!
  product: ProductCreateNestedOneWithoutProductSalesInput!
  quantity: Int!
}

type ProductSalesGroupBy {
  _avg: ProductSalesAvgAggregate
  _count: ProductSalesCountAggregate
  _max: ProductSalesMaxAggregate
  _min: ProductSalesMinAggregate
  _sum: ProductSalesSumAggregate
  customerId: String!
  dateCreated: DateTimeISO!
  dateUpdated: DateTimeISO!
  id: String!
  price: Float!
  productId: String!
  quantity: Int!
  userId: String!
}

input ProductSalesListRelationFilter {
  every: ProductSalesWhereInput
  none: ProductSalesWhereInput
  some: ProductSalesWhereInput
}

type ProductSalesMaxAggregate {
  customerId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float
  productId: String
  quantity: Int
  userId: String
}

input ProductSalesMaxOrderByAggregateInput {
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  userId: SortOrder
}

type ProductSalesMinAggregate {
  customerId: String
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float
  productId: String
  quantity: Int
  userId: String
}

input ProductSalesMinOrderByAggregateInput {
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  userId: SortOrder
}

input ProductSalesOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductSalesOrderByWithAggregationInput {
  _avg: ProductSalesAvgOrderByAggregateInput
  _count: ProductSalesCountOrderByAggregateInput
  _max: ProductSalesMaxOrderByAggregateInput
  _min: ProductSalesMinOrderByAggregateInput
  _sum: ProductSalesSumOrderByAggregateInput
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
  userId: SortOrder
}

input ProductSalesOrderByWithRelationInput {
  Customer: CustomerOrderByWithRelationInput
  User: UserOrderByWithRelationInput
  customerId: SortOrder
  dateCreated: SortOrder
  dateUpdated: SortOrder
  id: SortOrder
  price: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
  userId: SortOrder
}

enum ProductSalesScalarFieldEnum {
  customerId
  dateCreated
  dateUpdated
  id
  price
  productId
  quantity
  userId
}

input ProductSalesScalarWhereInput {
  AND: [ProductSalesScalarWhereInput!]
  NOT: [ProductSalesScalarWhereInput!]
  OR: [ProductSalesScalarWhereInput!]
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  price: FloatFilter
  productId: StringFilter
  quantity: IntFilter
  userId: StringFilter
}

input ProductSalesScalarWhereWithAggregatesInput {
  AND: [ProductSalesScalarWhereWithAggregatesInput!]
  NOT: [ProductSalesScalarWhereWithAggregatesInput!]
  OR: [ProductSalesScalarWhereWithAggregatesInput!]
  customerId: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  price: FloatWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type ProductSalesSumAggregate {
  price: Float
  quantity: Int
}

input ProductSalesSumOrderByAggregateInput {
  price: SortOrder
  quantity: SortOrder
}

input ProductSalesUpdateInput {
  Customer: CustomerUpdateOneRequiredWithoutProductSalesNestedInput
  User: UserUpdateOneRequiredWithoutProductSalesNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float
  product: ProductUpdateOneRequiredWithoutProductSalesNestedInput
  quantity: Int
}

input ProductSalesUpdateManyMutationInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float
  quantity: Int
}

input ProductSalesUpdateManyWithWhereWithoutCustomerInput {
  data: ProductSalesUpdateManyMutationInput!
  where: ProductSalesScalarWhereInput!
}

input ProductSalesUpdateManyWithWhereWithoutProductInput {
  data: ProductSalesUpdateManyMutationInput!
  where: ProductSalesScalarWhereInput!
}

input ProductSalesUpdateManyWithWhereWithoutUserInput {
  data: ProductSalesUpdateManyMutationInput!
  where: ProductSalesScalarWhereInput!
}

input ProductSalesUpdateManyWithoutCustomerNestedInput {
  connect: [ProductSalesWhereUniqueInput!]
  connectOrCreate: [ProductSalesCreateOrConnectWithoutCustomerInput!]
  create: [ProductSalesCreateWithoutCustomerInput!]
  createMany: ProductSalesCreateManyCustomerInputEnvelope
  delete: [ProductSalesWhereUniqueInput!]
  deleteMany: [ProductSalesScalarWhereInput!]
  disconnect: [ProductSalesWhereUniqueInput!]
  set: [ProductSalesWhereUniqueInput!]
  update: [ProductSalesUpdateWithWhereUniqueWithoutCustomerInput!]
  updateMany: [ProductSalesUpdateManyWithWhereWithoutCustomerInput!]
  upsert: [ProductSalesUpsertWithWhereUniqueWithoutCustomerInput!]
}

input ProductSalesUpdateManyWithoutProductNestedInput {
  connect: [ProductSalesWhereUniqueInput!]
  connectOrCreate: [ProductSalesCreateOrConnectWithoutProductInput!]
  create: [ProductSalesCreateWithoutProductInput!]
  createMany: ProductSalesCreateManyProductInputEnvelope
  delete: [ProductSalesWhereUniqueInput!]
  deleteMany: [ProductSalesScalarWhereInput!]
  disconnect: [ProductSalesWhereUniqueInput!]
  set: [ProductSalesWhereUniqueInput!]
  update: [ProductSalesUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ProductSalesUpdateManyWithWhereWithoutProductInput!]
  upsert: [ProductSalesUpsertWithWhereUniqueWithoutProductInput!]
}

input ProductSalesUpdateManyWithoutUserNestedInput {
  connect: [ProductSalesWhereUniqueInput!]
  connectOrCreate: [ProductSalesCreateOrConnectWithoutUserInput!]
  create: [ProductSalesCreateWithoutUserInput!]
  createMany: ProductSalesCreateManyUserInputEnvelope
  delete: [ProductSalesWhereUniqueInput!]
  deleteMany: [ProductSalesScalarWhereInput!]
  disconnect: [ProductSalesWhereUniqueInput!]
  set: [ProductSalesWhereUniqueInput!]
  update: [ProductSalesUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [ProductSalesUpdateManyWithWhereWithoutUserInput!]
  upsert: [ProductSalesUpsertWithWhereUniqueWithoutUserInput!]
}

input ProductSalesUpdateWithWhereUniqueWithoutCustomerInput {
  data: ProductSalesUpdateWithoutCustomerInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesUpdateWithWhereUniqueWithoutProductInput {
  data: ProductSalesUpdateWithoutProductInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesUpdateWithWhereUniqueWithoutUserInput {
  data: ProductSalesUpdateWithoutUserInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesUpdateWithoutCustomerInput {
  User: UserUpdateOneRequiredWithoutProductSalesNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float
  product: ProductUpdateOneRequiredWithoutProductSalesNestedInput
  quantity: Int
}

input ProductSalesUpdateWithoutProductInput {
  Customer: CustomerUpdateOneRequiredWithoutProductSalesNestedInput
  User: UserUpdateOneRequiredWithoutProductSalesNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float
  quantity: Int
}

input ProductSalesUpdateWithoutUserInput {
  Customer: CustomerUpdateOneRequiredWithoutProductSalesNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  id: String
  price: Float
  product: ProductUpdateOneRequiredWithoutProductSalesNestedInput
  quantity: Int
}

input ProductSalesUpsertWithWhereUniqueWithoutCustomerInput {
  create: ProductSalesCreateWithoutCustomerInput!
  update: ProductSalesUpdateWithoutCustomerInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesUpsertWithWhereUniqueWithoutProductInput {
  create: ProductSalesCreateWithoutProductInput!
  update: ProductSalesUpdateWithoutProductInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesUpsertWithWhereUniqueWithoutUserInput {
  create: ProductSalesCreateWithoutUserInput!
  update: ProductSalesUpdateWithoutUserInput!
  where: ProductSalesWhereUniqueInput!
}

input ProductSalesWhereInput {
  AND: [ProductSalesWhereInput!]
  Customer: CustomerRelationFilter
  NOT: [ProductSalesWhereInput!]
  OR: [ProductSalesWhereInput!]
  User: UserRelationFilter
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: StringFilter
  price: FloatFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  userId: StringFilter
}

input ProductSalesWhereUniqueInput {
  AND: [ProductSalesWhereInput!]
  Customer: CustomerRelationFilter
  NOT: [ProductSalesWhereInput!]
  OR: [ProductSalesWhereInput!]
  User: UserRelationFilter
  customerId: StringFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  id: String
  price: FloatFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
  userId: StringFilter
}

enum ProductScalarFieldEnum {
  dateCreated
  dateUpdated
  description
  id
  name
  price
  type
}

input ProductScalarWhereWithAggregatesInput {
  AND: [ProductScalarWhereWithAggregatesInput!]
  NOT: [ProductScalarWhereWithAggregatesInput!]
  OR: [ProductScalarWhereWithAggregatesInput!]
  dateCreated: DateTimeWithAggregatesFilter
  dateUpdated: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  price: FloatWithAggregatesFilter
  type: StringWithAggregatesFilter
}

type ProductSumAggregate {
  price: Float
}

input ProductSumOrderByAggregateInput {
  price: SortOrder
}

input ProductUpdateInput {
  Inventory: InventoryUpdateManyWithoutProductNestedInput
  ProductColor: ProductColorUpdateManyWithoutProductNestedInput
  ProductSales: ProductSalesUpdateManyWithoutProductNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String
  id: String
  name: String
  price: Float
  type: String
}

input ProductUpdateManyMutationInput {
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String
  id: String
  name: String
  price: Float
  type: String
}

input ProductUpdateOneRequiredWithoutInventoryNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutInventoryInput
  create: ProductCreateWithoutInventoryInput
  update: ProductUpdateToOneWithWhereWithoutInventoryInput
  upsert: ProductUpsertWithoutInventoryInput
}

input ProductUpdateOneRequiredWithoutProductColorNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductColorInput
  create: ProductCreateWithoutProductColorInput
  update: ProductUpdateToOneWithWhereWithoutProductColorInput
  upsert: ProductUpsertWithoutProductColorInput
}

input ProductUpdateOneRequiredWithoutProductSalesNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutProductSalesInput
  create: ProductCreateWithoutProductSalesInput
  update: ProductUpdateToOneWithWhereWithoutProductSalesInput
  upsert: ProductUpsertWithoutProductSalesInput
}

input ProductUpdateToOneWithWhereWithoutInventoryInput {
  data: ProductUpdateWithoutInventoryInput!
  where: ProductWhereInput
}

input ProductUpdateToOneWithWhereWithoutProductColorInput {
  data: ProductUpdateWithoutProductColorInput!
  where: ProductWhereInput
}

input ProductUpdateToOneWithWhereWithoutProductSalesInput {
  data: ProductUpdateWithoutProductSalesInput!
  where: ProductWhereInput
}

input ProductUpdateWithoutInventoryInput {
  ProductColor: ProductColorUpdateManyWithoutProductNestedInput
  ProductSales: ProductSalesUpdateManyWithoutProductNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String
  id: String
  name: String
  price: Float
  type: String
}

input ProductUpdateWithoutProductColorInput {
  Inventory: InventoryUpdateManyWithoutProductNestedInput
  ProductSales: ProductSalesUpdateManyWithoutProductNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String
  id: String
  name: String
  price: Float
  type: String
}

input ProductUpdateWithoutProductSalesInput {
  Inventory: InventoryUpdateManyWithoutProductNestedInput
  ProductColor: ProductColorUpdateManyWithoutProductNestedInput
  dateCreated: DateTimeISO
  dateUpdated: DateTimeISO
  description: String
  id: String
  name: String
  price: Float
  type: String
}

input ProductUpsertWithoutInventoryInput {
  create: ProductCreateWithoutInventoryInput!
  update: ProductUpdateWithoutInventoryInput!
  where: ProductWhereInput
}

input ProductUpsertWithoutProductColorInput {
  create: ProductCreateWithoutProductColorInput!
  update: ProductUpdateWithoutProductColorInput!
  where: ProductWhereInput
}

input ProductUpsertWithoutProductSalesInput {
  create: ProductCreateWithoutProductSalesInput!
  update: ProductUpdateWithoutProductSalesInput!
  where: ProductWhereInput
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  Inventory: InventoryListRelationFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  ProductColor: ProductColorListRelationFilter
  ProductSales: ProductSalesListRelationFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  description: StringFilter
  id: StringFilter
  name: StringFilter
  price: FloatFilter
  type: StringFilter
}

input ProductWhereUniqueInput {
  AND: [ProductWhereInput!]
  Inventory: InventoryListRelationFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  ProductColor: ProductColorListRelationFilter
  ProductSales: ProductSalesListRelationFilter
  dateCreated: DateTimeFilter
  dateUpdated: DateTimeFilter
  description: StringFilter
  id: String
  name: StringFilter
  price: FloatFilter
  type: StringFilter
}

type Query {
  aggregateColor(cursor: ColorWhereUniqueInput, orderBy: [ColorOrderByWithRelationInput!], skip: Int, take: Int, where: ColorWhereInput): AggregateColor!
  aggregateCustomer(cursor: CustomerWhereUniqueInput, orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): AggregateCustomer!
  aggregateInventory(cursor: InventoryWhereUniqueInput, orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): AggregateInventory!
  aggregateLoginHistory(cursor: LoginHistoryWhereUniqueInput, orderBy: [LoginHistoryOrderByWithRelationInput!], skip: Int, take: Int, where: LoginHistoryWhereInput): AggregateLoginHistory!
  aggregateProduct(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct!
  aggregateProductColor(cursor: ProductColorWhereUniqueInput, orderBy: [ProductColorOrderByWithRelationInput!], skip: Int, take: Int, where: ProductColorWhereInput): AggregateProductColor!
  aggregateProductSales(cursor: ProductSalesWhereUniqueInput, orderBy: [ProductSalesOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): AggregateProductSales!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  color(where: ColorWhereUniqueInput!): Color
  colors(cursor: ColorWhereUniqueInput, distinct: [ColorScalarFieldEnum!], orderBy: [ColorOrderByWithRelationInput!], skip: Int, take: Int, where: ColorWhereInput): [Color!]!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): [Customer!]!
  findFirstColor(cursor: ColorWhereUniqueInput, distinct: [ColorScalarFieldEnum!], orderBy: [ColorOrderByWithRelationInput!], skip: Int, take: Int, where: ColorWhereInput): Color
  findFirstColorOrThrow(cursor: ColorWhereUniqueInput, distinct: [ColorScalarFieldEnum!], orderBy: [ColorOrderByWithRelationInput!], skip: Int, take: Int, where: ColorWhereInput): Color
  findFirstCustomer(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstCustomerOrThrow(cursor: CustomerWhereUniqueInput, distinct: [CustomerScalarFieldEnum!], orderBy: [CustomerOrderByWithRelationInput!], skip: Int, take: Int, where: CustomerWhereInput): Customer
  findFirstInventory(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstInventoryOrThrow(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): Inventory
  findFirstLoginHistory(cursor: LoginHistoryWhereUniqueInput, distinct: [LoginHistoryScalarFieldEnum!], orderBy: [LoginHistoryOrderByWithRelationInput!], skip: Int, take: Int, where: LoginHistoryWhereInput): LoginHistory
  findFirstLoginHistoryOrThrow(cursor: LoginHistoryWhereUniqueInput, distinct: [LoginHistoryScalarFieldEnum!], orderBy: [LoginHistoryOrderByWithRelationInput!], skip: Int, take: Int, where: LoginHistoryWhereInput): LoginHistory
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductColor(cursor: ProductColorWhereUniqueInput, distinct: [ProductColorScalarFieldEnum!], orderBy: [ProductColorOrderByWithRelationInput!], skip: Int, take: Int, where: ProductColorWhereInput): ProductColor
  findFirstProductColorOrThrow(cursor: ProductColorWhereUniqueInput, distinct: [ProductColorScalarFieldEnum!], orderBy: [ProductColorOrderByWithRelationInput!], skip: Int, take: Int, where: ProductColorWhereInput): ProductColor
  findFirstProductOrThrow(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductSales(cursor: ProductSalesWhereUniqueInput, distinct: [ProductSalesScalarFieldEnum!], orderBy: [ProductSalesOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): ProductSales
  findFirstProductSalesOrThrow(cursor: ProductSalesWhereUniqueInput, distinct: [ProductSalesScalarFieldEnum!], orderBy: [ProductSalesOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): ProductSales
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyProductSales(cursor: ProductSalesWhereUniqueInput, distinct: [ProductSalesScalarFieldEnum!], orderBy: [ProductSalesOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): [ProductSales!]!
  findUniqueProductSales(where: ProductSalesWhereUniqueInput!): ProductSales
  findUniqueProductSalesOrThrow(where: ProductSalesWhereUniqueInput!): ProductSales
  getColor(where: ColorWhereUniqueInput!): Color
  getCustomer(where: CustomerWhereUniqueInput!): Customer
  getInventory(where: InventoryWhereUniqueInput!): Inventory
  getLoginHistory(where: LoginHistoryWhereUniqueInput!): LoginHistory
  getProduct(where: ProductWhereUniqueInput!): Product
  getProductColor(where: ProductColorWhereUniqueInput!): ProductColor
  getUser(where: UserWhereUniqueInput!): User
  groupByColor(by: [ColorScalarFieldEnum!]!, having: ColorScalarWhereWithAggregatesInput, orderBy: [ColorOrderByWithAggregationInput!], skip: Int, take: Int, where: ColorWhereInput): [ColorGroupBy!]!
  groupByCustomer(by: [CustomerScalarFieldEnum!]!, having: CustomerScalarWhereWithAggregatesInput, orderBy: [CustomerOrderByWithAggregationInput!], skip: Int, take: Int, where: CustomerWhereInput): [CustomerGroupBy!]!
  groupByInventory(by: [InventoryScalarFieldEnum!]!, having: InventoryScalarWhereWithAggregatesInput, orderBy: [InventoryOrderByWithAggregationInput!], skip: Int, take: Int, where: InventoryWhereInput): [InventoryGroupBy!]!
  groupByLoginHistory(by: [LoginHistoryScalarFieldEnum!]!, having: LoginHistoryScalarWhereWithAggregatesInput, orderBy: [LoginHistoryOrderByWithAggregationInput!], skip: Int, take: Int, where: LoginHistoryWhereInput): [LoginHistoryGroupBy!]!
  groupByProduct(by: [ProductScalarFieldEnum!]!, having: ProductScalarWhereWithAggregatesInput, orderBy: [ProductOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductWhereInput): [ProductGroupBy!]!
  groupByProductColor(by: [ProductColorScalarFieldEnum!]!, having: ProductColorScalarWhereWithAggregatesInput, orderBy: [ProductColorOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductColorWhereInput): [ProductColorGroupBy!]!
  groupByProductSales(by: [ProductSalesScalarFieldEnum!]!, having: ProductSalesScalarWhereWithAggregatesInput, orderBy: [ProductSalesOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): [ProductSalesGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  inventories(cursor: InventoryWhereUniqueInput, distinct: [InventoryScalarFieldEnum!], orderBy: [InventoryOrderByWithRelationInput!], skip: Int, take: Int, where: InventoryWhereInput): [Inventory!]!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  loginHistories(cursor: LoginHistoryWhereUniqueInput, distinct: [LoginHistoryScalarFieldEnum!], orderBy: [LoginHistoryOrderByWithRelationInput!], skip: Int, take: Int, where: LoginHistoryWhereInput): [LoginHistory!]!
  loginHistory(where: LoginHistoryWhereUniqueInput!): LoginHistory
  product(where: ProductWhereUniqueInput!): Product
  productColor(where: ProductColorWhereUniqueInput!): ProductColor
  productColors(cursor: ProductColorWhereUniqueInput, distinct: [ProductColorScalarFieldEnum!], orderBy: [ProductColorOrderByWithRelationInput!], skip: Int, take: Int, where: ProductColorWhereInput): [ProductColor!]!
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  signIn(password: String!, userName: String!): String!
  signOut: Boolean!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  LoginHistory(cursor: LoginHistoryWhereUniqueInput, distinct: [LoginHistoryScalarFieldEnum!], orderBy: [LoginHistoryOrderByWithRelationInput!], skip: Int, take: Int, where: LoginHistoryWhereInput): [LoginHistory!]!
  _count: UserCount
  address: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  productSales(cursor: ProductSalesWhereUniqueInput, distinct: [ProductSalesScalarFieldEnum!], orderBy: [ProductSalesOrderByWithRelationInput!], skip: Int, take: Int, where: ProductSalesWhereInput): [ProductSales!]!
  role: String!
}

type UserCount {
  LoginHistory(where: LoginHistoryWhereInput): Int!
  productSales(where: ProductSalesWhereInput): Int!
}

type UserCountAggregate {
  _all: Int!
  address: Int!
  dateCreated: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
  phone: Int!
  role: Int!
}

input UserCountOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

input UserCreateInput {
  LoginHistory: LoginHistoryCreateNestedManyWithoutUserInput
  address: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  productSales: ProductSalesCreateNestedManyWithoutUserInput
  role: String!
}

input UserCreateManyInput {
  address: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

input UserCreateNestedOneWithoutLoginHistoryInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoginHistoryInput
  create: UserCreateWithoutLoginHistoryInput
}

input UserCreateNestedOneWithoutProductSalesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProductSalesInput
  create: UserCreateWithoutProductSalesInput
}

input UserCreateOrConnectWithoutLoginHistoryInput {
  create: UserCreateWithoutLoginHistoryInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProductSalesInput {
  create: UserCreateWithoutProductSalesInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutLoginHistoryInput {
  address: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  productSales: ProductSalesCreateNestedManyWithoutUserInput
  role: String!
}

input UserCreateWithoutProductSalesInput {
  LoginHistory: LoginHistoryCreateNestedManyWithoutUserInput
  address: String!
  dateCreated: DateTimeISO
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  address: String!
  dateCreated: DateTimeISO!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  phone: String!
  role: String!
}

type UserMaxAggregate {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserMaxOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

type UserMinAggregate {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserMinOrderByAggregateInput {
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  role: SortOrder
}

input UserOrderByWithRelationInput {
  LoginHistory: LoginHistoryOrderByRelationAggregateInput
  address: SortOrder
  dateCreated: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
  phone: SortOrder
  productSales: ProductSalesOrderByRelationAggregateInput
  role: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  address
  dateCreated
  email
  firstName
  id
  lastName
  password
  phone
  role
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  dateCreated: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  phone: StringWithAggregatesFilter
  role: StringWithAggregatesFilter
}

input UserUpdateInput {
  LoginHistory: LoginHistoryUpdateManyWithoutUserNestedInput
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  productSales: ProductSalesUpdateManyWithoutUserNestedInput
  role: String
}

input UserUpdateManyMutationInput {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserUpdateOneRequiredWithoutLoginHistoryNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutLoginHistoryInput
  create: UserCreateWithoutLoginHistoryInput
  update: UserUpdateToOneWithWhereWithoutLoginHistoryInput
  upsert: UserUpsertWithoutLoginHistoryInput
}

input UserUpdateOneRequiredWithoutProductSalesNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProductSalesInput
  create: UserCreateWithoutProductSalesInput
  update: UserUpdateToOneWithWhereWithoutProductSalesInput
  upsert: UserUpsertWithoutProductSalesInput
}

input UserUpdateToOneWithWhereWithoutLoginHistoryInput {
  data: UserUpdateWithoutLoginHistoryInput!
  where: UserWhereInput
}

input UserUpdateToOneWithWhereWithoutProductSalesInput {
  data: UserUpdateWithoutProductSalesInput!
  where: UserWhereInput
}

input UserUpdateWithoutLoginHistoryInput {
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  productSales: ProductSalesUpdateManyWithoutUserNestedInput
  role: String
}

input UserUpdateWithoutProductSalesInput {
  LoginHistory: LoginHistoryUpdateManyWithoutUserNestedInput
  address: String
  dateCreated: DateTimeISO
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  phone: String
  role: String
}

input UserUpsertWithoutLoginHistoryInput {
  create: UserCreateWithoutLoginHistoryInput!
  update: UserUpdateWithoutLoginHistoryInput!
  where: UserWhereInput
}

input UserUpsertWithoutProductSalesInput {
  create: UserCreateWithoutProductSalesInput!
  update: UserUpdateWithoutProductSalesInput!
  where: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  LoginHistory: LoginHistoryListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  productSales: ProductSalesListRelationFilter
  role: StringFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  LoginHistory: LoginHistoryListRelationFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: StringFilter
  dateCreated: DateTimeFilter
  email: String
  firstName: StringFilter
  id: String
  lastName: StringFilter
  password: StringFilter
  phone: StringFilter
  productSales: ProductSalesListRelationFilter
  role: StringFilter
}